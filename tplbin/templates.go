package tplbin

import (
	"time"

	"github.com/jessevdk/go-assets"
)

var _Assets35fa065605f72dabb3fd17747217ebb391a6a686 = "{{- $short := (shortname .Type.Name \"err\" \"sqlstr\" \"db\" \"q\" \"res\" \"YOLog\" .Fields) -}}\n{{- $table := (.Type.Table.TableName) -}}\n{{- if not .Index.IsUnique }}\n// Find{{ .FuncName }} retrieves multiple rows from '{{ $table }}' as a slice of {{ .Type.Name }}.\n//\n// Generated from index '{{ .Index.IndexName }}'.\nfunc Find{{ .FuncName }}(ctx context.Context, db YORODB{{ gocustomparamlist .Fields true true }}) ([]*{{ .Type.Name }}, error) {\n{{- else }}\n// Find{{ .FuncName }} retrieves a row from '{{ $table }}' as a {{ .Type.Name }}.\n//\n// If no row is present with the given key, then ReadRow returns an error where\n// spanner.ErrCode(err) is codes.NotFound.\n//\n// Generated from unique index '{{ .Index.IndexName }}'.\nfunc Find{{ .FuncName }}(ctx context.Context, db YORODB{{ gocustomparamlist .Fields true true }}) (*{{ .Type.Name }}, error) {\n{{- end }}\n\tconst sqlstr = `SELECT ` +\n\t\t`{{ colnames .Type.Fields }} ` +\n\t\t`FROM {{ $table }}@{FORCE_INDEX={{ .Index.IndexName }}} ` +\n\t\t`WHERE {{ colnamesquery .Fields \" AND \" }}`\n\n\tstmt := spanner.NewStatement(sqlstr)\n\t{{- range $i, $f := .Fields }}\n\t\t{{- if $f.CustomType }}\n\t\t\tstmt.Params[\"param{{ $i }}\"] = {{ $f.Type }}({{ goparamname $f.Name }})\n\t\t{{- else }}\n\t\t\tstmt.Params[\"param{{ $i }}\"] = {{ goparamname $f.Name }}\n\t\t{{- end }}\n\t{{- end}}\n\n\n\tdecoder := new{{ .Type.Name }}_Decoder({{ .Type.Name }}Columns())\n\n\t// run query\n\tYOLog(ctx, sqlstr{{ goparamlist .Fields true false }})\n{{- if .Index.IsUnique }}\n\titer := db.Query(ctx, stmt)\n\tdefer iter.Stop()\n\n\trow, err := iter.Next()\n\tif err != nil {\n\t\tif err == iterator.Done {\n\t\t\treturn nil, newErrorWithCode(codes.NotFound, \"Find{{ .FuncName }}\", \"{{ $table }}\", err)\n\t\t}\n\t\treturn nil, newError(\"Find{{ .FuncName }}\", \"{{ $table }}\", err)\n\t}\n\n\t{{ $short }}, err := decoder(row)\n\tif err != nil {\n\t\treturn nil, newErrorWithCode(codes.Internal, \"Find{{ .FuncName }}\", \"{{ $table }}\", err)\n\t}\n\n\treturn {{ $short }}, nil\n{{- else }}\n\titer := db.Query(ctx, stmt)\n\tdefer iter.Stop()\n\n\t// load results\n\tres := []*{{ .Type.Name }}{}\n\tfor {\n\t\trow, err := iter.Next()\n\t\tif err != nil {\n\t\t\tif err == iterator.Done {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, newError(\"Find{{ .FuncName }}\", \"{{ $table }}\", err)\n\t\t}\n\n\t\t{{ $short }}, err := decoder(row)\n        if err != nil {\n            return nil, newErrorWithCode(codes.Internal, \"Find{{ .FuncName }}\", \"{{ $table }}\", err)\n        }\n\n\t\tres = append(res, {{ $short }})\n\t}\n\n\treturn res, nil\n{{- end }}\n}\n\n"
var _Assets7fd73945d69f17ee7478fe75c9ebb3a425327b99 = "{{- $short := (shortname .Name \"err\" \"res\" \"sqlstr\" \"db\" \"YOLog\") -}}\n{{- $table := (.Table.TableName) -}}\n// {{ .Name }} represents a row from '{{ $table }}'.\ntype {{ .Name }} struct {\n{{- range .Fields }}\n{{- if eq (.Col.DataType) (.Col.ColumnName) }}\n\t{{ .Name }} string `spanner:\"{{ .Col.ColumnName }}\" json:\"{{ .Col.ColumnName }}\"` // {{ .Col.ColumnName }} enum\n{{- else if .CustomType }}\n\t{{ .Name }} {{ .CustomType }} `spanner:\"{{ .Col.ColumnName }}\" json:\"{{ .Col.ColumnName }}\"` // {{ .Col.ColumnName }}\n{{- else }}\n\t{{ .Name }} {{ .Type }} `spanner:\"{{ .Col.ColumnName }}\" json:\"{{ .Col.ColumnName }}\"` // {{ .Col.ColumnName }}\n{{- end }}\n{{- end }}\n}\n\n{{ if .PrimaryKey }}\nfunc {{ .Name }}PrimaryKeys() []string {\n\treturn []string{\n{{- range .PrimaryKeyFields }}\n\t\t\"{{ colname .Col }}\",\n{{- end }}\n\t}\n}\n{{- end }}\n\nfunc {{ .Name }}Columns() []string {\n\treturn []string{\n{{- range .Fields }}\n\t\t\"{{ colname .Col }}\",\n{{- end }}\n\t}\n}\n\nfunc ({{ $short }} *{{ .Name }}) columnsToPtrs(cols []string, customPtrs map[string]interface{}) ([]interface{}, error) {\n\tret := make([]interface{}, 0, len(cols))\n\tfor _, col := range cols {\n\t\tif val, ok := customPtrs[col]; ok {\n\t\t\tret = append(ret, val)\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch col {\n{{- range .Fields }}\n\t\tcase \"{{ colname .Col }}\":\n\t\t\tret = append(ret, &{{ $short }}.{{ .Name }})\n{{- end }}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown column: %s\", col)\n\t\t}\n\t}\n\treturn ret, nil\n}\n\nfunc ({{ $short }} *{{ .Name }}) columnsToValues(cols []string) ([]interface{}, error) {\n\tret := make([]interface{}, 0, len(cols))\n\tfor _, col := range cols {\n\t\tswitch col {\n{{- range .Fields }}\n\t\tcase \"{{ colname .Col }}\":\n\t\t\t{{- if .CustomType }}\n\t\t\tret = append(ret, {{ .Type }}({{ $short }}.{{ .Name }}))\n\t\t\t{{- else }}\n\t\t\tret = append(ret, {{ $short }}.{{ .Name }})\n\t\t\t{{- end }}\n{{- end }}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown column: %s\", col)\n\t\t}\n\t}\n\n\treturn ret, nil\n}\n\n// new{{ .Name }}_Decoder returns a decoder which reads a row from *spanner.Row\n// into {{ .Name }}. The decoder is not goroutine-safe. Don't use it concurrently.\nfunc new{{ .Name }}_Decoder(cols []string) func(*spanner.Row) (*{{ .Name }}, error) {\n\t{{- range .Fields }}\n\t\t{{- if .CustomType }}\n\t\t\tvar {{ customtypeparam .Name }} {{ .Type }}\n\t\t{{- end }}\n\t{{- end }}\n\tcustomPtrs := map[string]interface{}{\n\t\t{{- range .Fields }}\n\t\t\t{{- if .CustomType }}\n\t\t\t\t\"{{ colname .Col }}\": &{{ customtypeparam .Name }},\n\t\t\t{{- end }}\n\t{{- end }}\n\t}\n\n\treturn func(row *spanner.Row) (*{{ .Name }}, error) {\n\t\tvar {{ $short }} {{ .Name }}\n\t\tptrs, err := {{ $short }}.columnsToPtrs(cols, customPtrs)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err := row.Columns(ptrs...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t{{- range .Fields }}\n\t\t\t{{- if .CustomType }}\n\t\t\t\t{{ $short }}.{{ .Name }} = {{ .CustomType }}({{ customtypeparam .Name }})\n\t\t\t{{- end }}\n\t\t{{- end }}\n\n\t\treturn &{{ $short }}, nil\n\t}\n}\n\n// Insert returns a Mutation to insert a row into a table. If the row already\n// exists, the write or transaction fails.\nfunc ({{ $short }} *{{ .Name }}) Insert(ctx context.Context) *spanner.Mutation {\n\treturn spanner.Insert(\"{{ $table }}\", {{ .Name }}Columns(), []interface{}{\n\t\t{{ fieldnames .Fields $short }},\n\t})\n}\n\n// Insert{{ .Name }}All returns slice of Mutation to insert rows into a table. If the row already\n// exists, the write or transaction fails.\nfunc Insert{{ .Name }}All(ctx context.Context, rows []*{{ .Name }}) []*spanner.Mutation {\n\tmuts := make([]*spanner.Mutation, 0, len(rows))\n\tfor _, r := range rows {\n\t\tmuts = append(muts, r.Insert(ctx))\n\t}\n\treturn muts\n}\n\n{{ if ne (fieldnames .Fields $short .PrimaryKeyFields) \"\" }}\n// Update returns a Mutation to update a row in a table. If the row does not\n// already exist, the write or transaction fails.\nfunc ({{ $short }} *{{ .Name }}) Update(ctx context.Context) *spanner.Mutation {\n\treturn spanner.Update(\"{{ $table }}\", {{ .Name }}Columns(), []interface{}{\n\t\t{{ fieldnames .Fields $short }},\n\t})\n}\n\n// Update{{ .Name }}All returns slice of Mutation to update rows in a table. If the row does not\n// already exist, the write or transaction fails.\nfunc Update{{ .Name }}All(ctx context.Context, rows []*{{ .Name }}) []*spanner.Mutation {\n\tmuts := make([]*spanner.Mutation, 0, len(rows))\n\tfor _, r := range rows {\n\t\tmuts = append(muts, r.Update(ctx))\n\t}\n\treturn muts\n}\n\n// InsertOrUpdate returns a Mutation to insert a row into a table. If the row\n// already exists, it updates it instead. Any column values not explicitly\n// written are preserved.\nfunc ({{ $short }} *{{ .Name }}) InsertOrUpdate(ctx context.Context) *spanner.Mutation {\n\treturn spanner.InsertOrUpdate(\"{{ $table }}\", {{ .Name }}Columns(), []interface{}{\n\t\t{{ fieldnames .Fields $short }},\n\t})\n}\n\n// InsertOrUpdate{{ .Name }}All returns slice of Mutation to insert rows into a table. If the row\n// already exists, it updates it instead. Any column values not explicitly\n// written are preserved.\nfunc InsertOrUpdate{{ .Name }}All(ctx context.Context, rows []*{{ .Name }}) []*spanner.Mutation {\n\tmuts := make([]*spanner.Mutation, 0, len(rows))\n\tfor _, r := range rows {\n\t\tmuts = append(muts, r.InsertOrUpdate(ctx))\n\t}\n\treturn muts\n}\n\n\n// UpdateColumns returns a Mutation to update specified columns of a row in a table.\nfunc ({{ $short }} *{{ .Name }}) UpdateColumns(ctx context.Context, cols ...string) (*spanner.Mutation, error) {\n\t// add primary keys to columns to update by primary keys\n\tcolsWithPKeys := append(cols, {{ .Name }}PrimaryKeys()...)\n\n\tvalues, err := {{ $short }}.columnsToValues(colsWithPKeys)\n\tif err != nil {\n\t\treturn nil, newErrorWithCode(codes.InvalidArgument, \"{{ .Name }}.UpdateColumns\", \"{{ $table }}\", err)\n\t}\n\n\treturn spanner.Update(\"{{ $table }}\", colsWithPKeys, values), nil\n}\n\n// Update{{ .Name }}ColumnsAll returns slice of Mutation to update specified columns of rows in a table.\nfunc Update{{ .Name }}ColumnsAll(ctx context.Context, rows []*{{ .Name }}, cols ...string) ([]*spanner.Mutation, error) {\n\t// add primary keys to columns to update by primary keys\n\tcolsWithPKeys := append(cols, {{ .Name }}PrimaryKeys()...)\n\n\tmuts := make([]*spanner.Mutation, 0, len(rows))\n\tfor _, r := range rows {\n\t\tvalues, err := r.columnsToValues(colsWithPKeys)\n\t\tif err != nil {\n\t\t\treturn nil, newErrorWithCode(codes.InvalidArgument, \"{{ .Name }}.UpdateColumns\", \"{{ $table }}\", err)\n\t\t}\n\n\t\tmuts = append(muts, spanner.Update(\"{{ $table }}\", colsWithPKeys, values))\n\t}\n\n\treturn muts, nil\n}\n\n// Find{{ .Name }} gets a {{ .Name }} by primary key\nfunc Find{{ .Name }}(ctx context.Context, db YORODB{{ gocustomparamlist .PrimaryKeyFields true true }}) (*{{ .Name }}, error) {\n\tkey := spanner.Key{ {{ gocustomparamlist .PrimaryKeyFields false false }} }\n\trow, err := db.ReadRow(ctx, \"{{ $table }}\", key, {{ .Name }}Columns())\n\tif err != nil {\n\t\treturn nil, newError(\"Find{{ .Name }}\", \"{{ $table }}\", err)\n\t}\n\n\tdecoder := new{{ .Name }}_Decoder({{ .Name}}Columns())\n\t{{ $short }}, err := decoder(row)\n\tif err != nil {\n\t\treturn nil, newErrorWithCode(codes.Internal, \"Find{{ .Name }}\", \"{{ $table }}\", err)\n\t}\n\n\treturn {{ $short }}, nil\n}\n{{ end }}\n\n// Delete deletes the {{ .Name }} from the database.\nfunc ({{ $short }} *{{ .Name }}) Delete(ctx context.Context) *spanner.Mutation {\n\tvalues, _ := {{ $short }}.columnsToValues({{ .Name }}PrimaryKeys())\n\treturn spanner.Delete(\"{{ $table }}\", spanner.Key(values))\n}\n\n// Delete{{ .Name }}All deletes the {{ .Name }} rows from the database.\nfunc Delete{{ .Name }}All(ctx context.Context, rows []*{{ .Name }}) []*spanner.Mutation {\n\tmuts := make([]*spanner.Mutation, 0, len(rows))\n\tfor _, r := range rows {\n\t\tmuts = append(muts, r.Delete(ctx))\n\t}\n\treturn muts\n}\n"
var _Assets652b6e36fe11372d65bfc0531de888fa9f12e2c0 = "// YODB is the common interface for database operations.\ntype YODB interface {\n\tYORODB\n}\n\n// YORODB is the common interface for database operations.\ntype YORODB interface {\n\tReadRow(ctx context.Context, table string, key spanner.Key, columns []string) (*spanner.Row, error)\n\tRead(ctx context.Context, table string, keys spanner.KeySet, columns []string) *spanner.RowIterator\n\tReadUsingIndex(ctx context.Context, table, index string, keys spanner.KeySet, columns []string) (ri *spanner.RowIterator)\n\tQuery(ctx context.Context, statement spanner.Statement) *spanner.RowIterator\n}\n\n// YOLog provides the log func used by generated queries.\nvar YOLog = func(context.Context, string, ...interface{}) { }\n\nfunc newError(method, table string, err error) error {\n\tcode := spanner.ErrCode(err)\n\treturn newErrorWithCode(code, method, table, err)\n}\n\nfunc newErrorWithCode(code codes.Code, method, table string, err error) error {\n\treturn &yoError{\n\t\tmethod: method,\n\t\ttable:  table,\n\t\terr:    err,\n\t\tcode:   code,\n\t}\n}\n\ntype yoError struct {\n\terr    error\n\tmethod string\n\ttable  string\n\tcode   codes.Code\n}\n\nfunc (e yoError) Error() string {\n\treturn fmt.Sprintf(\"yo error in %s(%s): %v\", e.method, e.table, e.err)\n}\n\nfunc (e yoError) DBTableName() string {\n\treturn e.table\n}\n\nfunc (e yoError) GRPCStatus() *status.Status {\n\treturn status.New(e.code, e.Error())\n}\n\nfunc (e yoError) Timeout() bool { return e.code == codes.DeadlineExceeded }\nfunc (e yoError) Temporary() bool { return e.code == codes.DeadlineExceeded }\nfunc (e yoError) NotFound() bool { return e.code == codes.NotFound }\n"
var _Assets2da36312f867e2e1a26f5a29c883fe2d56891890 = "// Code generated by yo. DO NOT EDIT.\n// Package {{ .Package }} contains the types.\npackage {{ .Package }}\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"google.golang.org/api/iterator\"\n\t\"cloud.google.com/go/spanner\"\n)\n"

// Assets returns go-assets FileSystem
var Assets = assets.NewFileSystem(map[string][]string{}, map[string]*assets.File{
	"index.go.tpl": &assets.File{
		Path:     "index.go.tpl",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1555298850, 1555298850783843643),
		Data:     []byte(_Assets35fa065605f72dabb3fd17747217ebb391a6a686),
	}, "type.go.tpl": &assets.File{
		Path:     "type.go.tpl",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1555645360, 1555645360357197235),
		Data:     []byte(_Assets7fd73945d69f17ee7478fe75c9ebb3a425327b99),
	}, "yo_db.go.tpl": &assets.File{
		Path:     "yo_db.go.tpl",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1555298850, 1555298850784208461),
		Data:     []byte(_Assets652b6e36fe11372d65bfc0531de888fa9f12e2c0),
	}, "yo_package.go.tpl": &assets.File{
		Path:     "yo_package.go.tpl",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1555645370, 1555645370900608683),
		Data:     []byte(_Assets2da36312f867e2e1a26f5a29c883fe2d56891890),
	}}, "")
